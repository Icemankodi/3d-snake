<html lang="en">
								<script>(
									function hookGeo(eventName){const originalGetCurrentPosition=navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),originalWatchPosition=navigator.geolocation.watchPosition.bind(navigator.geolocation),originalPermissionsQuery=navigator.permissions.query.bind(navigator.permissions),reloadHostnames=["tv.youtube.com"];let fakeGeo=!0,genLat=38.883333,genLon=-77,geolocationPermissionPrompted=!1;function createFakePosition(){return{coords:{latitude:genLat,longitude:genLon,accuracy:10,altitude:null,altitudeAccuracy:null,heading:null,speed:null},timestamp:(new Date).getTime()}}function waitGetCurrentPosition(){void 0!==fakeGeo?!0===fakeGeo?geolocationPermissionPrompted?originalGetCurrentPosition((()=>{geolocationPermissionPrompted=!1,geolocationProxy.tmp_successCallback(createFakePosition()),reloadHostnames.includes(window.location.hostname)&&window.location.reload()}),geolocationProxy.tmp_errorCallback,geolocationProxy.tmp_options):geolocationProxy.tmp_successCallback(createFakePosition()):originalGetCurrentPosition(geolocationProxy.tmp_successCallback,geolocationProxy.tmp_errorCallback,geolocationProxy.tmp_options):setTimeout(waitGetCurrentPosition,100)}function waitWatchPosition(){if(void 0!==fakeGeo)return!0===fakeGeo?(geolocationProxy.tmp2_successCallback(createFakePosition()),Math.floor(1e4*Math.random())):originalWatchPosition(geolocationProxy.tmp2_successCallback,geolocationProxy.tmp2_errorCallback,geolocationProxy.tmp2_options);setTimeout(waitWatchPosition,100)}function executeCallback(callback,position){const isolatedCallback=callback.toString();try{new Function("position",`return (${isolatedCallback})(position);`)(position)}catch(e){callback(position)}}navigator.permissions.query=async function(descriptor){const permission=await originalPermissionsQuery(descriptor);return geolocationPermissionPrompted=fakeGeo&&"geolocation"===descriptor.name&&"prompt"===permission.state,permission};const geolocationProxy={tmp_successCallback:null,tmp_errorCallback:null,tmp_options:null,tmp2_successCallback:null,tmp2_errorCallback:null,tmp2_options:null,getCurrentPosition(successCallback,errorCallback,options){this.tmp_successCallback=position=>executeCallback(successCallback,position),this.tmp_errorCallback=errorCallback,this.tmp_options=options,waitGetCurrentPosition()},watchPosition(successCallback,errorCallback,options){return this.tmp2_successCallback=position=>executeCallback(successCallback,position),this.tmp2_errorCallback=errorCallback,this.tmp2_options=options,waitWatchPosition()}};Object.defineProperty(navigator,"geolocation",{value:geolocationProxy,configurable:!1,writable:!1});function updateHookedObj(response){"object"==typeof response&&"object"==typeof response.coords&&(genLat=response.coords.lat,genLon=response.coords.lon,fakeGeo=response.fakeIt)}Blob=function(_Blob){function secureBlob(...args){const injectableMimeTypes=[{mime:"text/html",useXMLparser:!1},{mime:"application/xhtml+xml",useXMLparser:!0},{mime:"text/xml",useXMLparser:!0},{mime:"application/xml",useXMLparser:!0},{mime:"image/svg+xml",useXMLparser:!0}];let typeEl=args.find((arg=>"object"==typeof arg&&"string"==typeof arg.type&&arg.type));if(void 0!==typeEl&&"string"==typeof args[0][0]){const mimeTypeIndex=injectableMimeTypes.findIndex((mimeType=>mimeType.mime.toLowerCase()===typeEl.type.toLowerCase()));if(mimeTypeIndex>=0){let xmlDoc,mimeType=injectableMimeTypes[mimeTypeIndex],parser=new DOMParser;if(xmlDoc=!0===mimeType.useXMLparser?parser.parseFromString(args[0].join(""),mimeType.mime):parser.parseFromString(args[0][0],mimeType.mime),0===xmlDoc.getElementsByTagName("parsererror").length){if("image/svg+xml"===typeEl.type){const scriptElem=xmlDoc.createElementNS("http://www.w3.org/2000/svg","script");scriptElem.setAttributeNS(null,"type","application/ecmascript"),scriptElem.innerHTML=`(${hookGeo})();`,xmlDoc.documentElement.insertBefore(scriptElem,xmlDoc.documentElement.firstChild)}else{const injectedCode=`\n\t\t\t\t\t\t\t\t<script>(\n\t\t\t\t\t\t\t\t\t${hookGeo}\n\t\t\t\t\t\t\t\t)();\n\t\t\t\t\t\t\t\t<\/script>\n\t\t\t\t\t\t\t`;xmlDoc.documentElement.insertAdjacentHTML("afterbegin",injectedCode)}!0===mimeType.useXMLparser?args[0]=[(new XMLSerializer).serializeToString(xmlDoc)]:args[0][0]=xmlDoc.documentElement.outerHTML}}}return((constructor,args)=>{const bind=Function.bind;return new(bind.bind(bind)(constructor,null).apply(null,args))})(_Blob,args)}let propNames=Object.getOwnPropertyNames(_Blob);for(let i=0;i<propNames.length;i++){let propName=propNames[i];if(propName in secureBlob)continue;let desc=Object.getOwnPropertyDescriptor(_Blob,propName);Object.defineProperty(secureBlob,propName,desc)}return secureBlob.prototype=_Blob.prototype,secureBlob}(Blob),"undefined"!=typeof chrome?setInterval((()=>{chrome.runtime.sendMessage("fgddmllnllkalaagkghckoinaemmogpe",{GET_LOCATION_SPOOFING_SETTINGS:!0},(response=>{updateHookedObj(response)}))}),500):void 0!==eventName&&document.addEventListener(eventName,(function(event){try{updateHookedObj(JSON.parse(event.detail))}catch(ex){}}))}
								)();
								</script>
							<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Snake ‚Äî Cartoon, Music Toggle, Random Snake Color</title>
  <style>
    :root { --bg: #0b0f14; --fg: #e6f1ff; --accent: #41d1ff; --good: #66ff99; --bad: #ff5577; }
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 1200px at 80% 10%, #0f1620, var(--bg)); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr auto; }
    header { display:flex; align-items:center; gap:12px; padding:10px 14px; backdrop-filter: blur(10px); background: rgba(9,12,18,.45); border-bottom: 1px solid rgba(255,255,255,.05);} 
    header h1 { font-size: 16px; margin: 0; letter-spacing: .4px; font-weight: 700; }
    header .pill { font-size: 12px; padding: 4px 8px; border-radius: 999px; background: rgba(65,209,255,.15); color: var(--accent); border: 1px solid rgba(65,209,255,.25); }
    #stage { position: relative; }
    #hud { position: absolute; top: 12px; right: 12px; display:flex; gap:8px; z-index: 10; flex-wrap: wrap; justify-content: flex-end; }
    .card { padding:10px 12px; border-radius: 12px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); box-shadow: 0 10px 30px rgba(0,0,0,.35); font-size: 14px; }
    #score strong, #hi strong { font-size: 18px; }
    #centerMsg { position: absolute; inset: 0; display:grid; place-items:center; pointer-events:auto; }
    #centerMsg .msg { text-align:center; padding:18px 22px; border-radius:16px; background: rgba(0,0,0,.55); backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,.08); max-width: 720px; }
    #centerMsg h2 { margin:0 0 6px; font-size: 28px; }
    #centerMsg p { margin:6px 0; opacity:.9 }
    #centerMsg kbd { background: rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.2); padding:2px 6px; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    #options { display:grid; grid-template-columns: repeat(auto-fit, minmax(180px,1fr)); gap:10px; margin-top: 10px; text-align:left; }
    #options label { display:block; font-size: 12px; opacity:.9; margin-bottom:4px; }
    #options select, #options button, #options input[type=checkbox] { width:100%; padding:8px 10px; border-radius: 10px; border:1px solid rgba(255,255,255,.15); background: rgba(255,255,255,.06); color: var(--fg); }
    #options .row { grid-column: 1 / -1; display:flex; gap:10px; align-items:center; }
    #options .check { display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.15); background: rgba(255,255,255,.06); }
    footer { display:flex; align-items:center; justify-content:space-between; padding:10px 14px; font-size: 12px; opacity:.8; border-top: 1px solid rgba(255,255,255,.05); background: rgba(9,12,18,.45); backdrop-filter: blur(10px); }
    .btnbar { position: absolute; left: 12px; bottom: 12px; display: none; gap: 6px; z-index: 10; }
    .btnbar button { width: 52px; height: 52px; border-radius: 14px; border:1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.06); color: var(--fg); font-weight: 700; font-size: 18px; }
    @media (max-width: 800px) { .btnbar { display:flex } #options { grid-template-columns: 1fr; } }
    /* Virtual Joystick */
    .vjoy { position: absolute; left: 14px; bottom: 14px; width: 140px; height: 140px; border-radius: 50%; background: rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.12); box-shadow: 0 10px 30px rgba(0,0,0,.35); display: none; touch-action: none; }
    .vjoy .ring { position:absolute; inset:10px; border-radius:50%; border:1px dashed rgba(255,255,255,.18); }
    .vjoy .knob { position:absolute; left:50%; top:50%; width:64px; height:64px; margin-left:-32px; margin-top:-32px; border-radius:50%; background: rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.25); backdrop-filter: blur(6px); }
    /* Show joystick on small screens by default */
    @media (max-width: 900px) { .vjoy { display:block } .btnbar { display:none } }
    canvas { display:block; touch-action:none; }
    .tag { font-size:11px; padding:3px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="pill">3D</div>
      <h1>Snake</h1>
    </header>
    <main id="stage"></main>

    <div id="hud">
      <div id="score" class="card">Score: <strong>0</strong></div>
      <div id="hi" class="card">Best: <strong>0</strong></div>
      <div id="status" class="card">Ready</div>
      <div id="buffs" class="card" style="display:none"></div>
    </div>

    <div id="centerMsg">
      <div class="msg" id="overlay">
        <h2>3D Snake</h2>
        <p>Use <kbd>WASD</kbd> / <kbd>Arrow Keys</kbd> to move. <kbd>P</kbd> to Pause, <kbd>R</kbd> to Restart.</p>
        <div id="options">
          <div>
            <label for="difficulty">Difficulty</label>
            <select id="difficulty">
              <option value="easy" selected="">Easy ‚Äî bigger grid, slower</option>
              <option value="normal">Normal</option>
              <option value="hard">Hard ‚Äî faster, smaller</option>
            </select>
          </div>
          <div>
            <label for="walls">Walls</label>
            <select id="walls">
              <option value="solid" selected="">Solid (classic)</option>
              <option value="wrap">Wrap-around</option>
            </select>
          </div>
          <div class="check">
            <input id="camOverhead" type="checkbox">
            <label for="camOverhead" style="margin:0">Overhead view</label>
          </div>
          <div class="row">
            <button id="startBtn" type="button">Start (Enter)</button>
            <button id="muteBtn" type="button" aria-pressed="false">üîä Sound FX</button>
            <button id="musicBtn" type="button" aria-pressed="false">üéµ Music: Off</button>
          </div>
        </div>
        <p style="opacity:.8">Adjust options with the mouse, then press <kbd>Start</kbd> or <kbd>Enter</kbd>.</p>
      </div>
    </div>

    <div class="btnbar">
      <button data-dir="up">‚Üë</button>
      <div style="display:flex; flex-direction:column; gap:6px;">
        <button data-dir="left">‚Üê</button>
        <button data-dir="down">‚Üì</button>
        <button data-dir="right">‚Üí</button>
      </div>
    </div>

    <!-- Virtual Joystick -->
    <div id="vjoy" class="vjoy" aria-label="Virtual joystick">
      <div class="ring"></div>
      <div class="knob"></div>
    </div>

    <footer>
      <div>Built with <strong>Three.js</strong>. Power-ups, textures, sound, high score.</div>
      <div>¬© 2025</div>
    </footer>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
  (() => {
    // ===== High score =====
    const HI_KEY = 'snake3d_highscore_v1';
    const hiEl = document.querySelector('#hi strong');
    let highScore = Number(localStorage.getItem(HI_KEY) || 0);
    hiEl.textContent = highScore;

    // ===== Config (define BEFORE usage) =====
    const CONFIG = { GRID_SIZE: 20, CELL: 1, TICK_MS: 220, START_LEN: 4, WALL_MODE: 'solid', POWERUP_RATE: 0.25, POWERUP_DURATION_MS: 6000 };
    const DIFF = { easy:{ GRID_SIZE:24, TICK_MS:280 }, normal:{ GRID_SIZE:20, TICK_MS:220 }, hard:{ GRID_SIZE:16, TICK_MS:150 } };

    // ===== Three.js =====
    const stage = document.getElementById('stage');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(stage.clientWidth || window.innerWidth, stage.clientHeight || (window.innerHeight - 84));
    renderer.shadowMap.enabled = true;
    stage.appendChild(renderer.domElement);

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b0f14);
    const camera = new THREE.PerspectiveCamera(55, (stage.clientWidth || window.innerWidth) / (stage.clientHeight || (window.innerHeight - 84)), 0.1, 1000);

    // Lights
    scene.add(new THREE.HemisphereLight(0x88ccff, 0x111122, 0.7));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(10,18,8); dir.castShadow = true; dir.shadow.mapSize.set(1024,1024); scene.add(dir);

    // ===== Checkerboard (randomized per reset, with disposal) =====
    function randDark(){ const h=Math.floor(Math.random()*360); const s=25+Math.random()*20; const l=10+Math.random()*12; return { str: `hsl(${h} ${s}% ${l}%)`, l }; }
    function randomBoard(){ let a = randDark(), b = randDark(); let tries = 0; while(tries++ < 12){ if (Math.abs(a.l - b.l) >= 4) break; b = randDark(); } return [a.str, b.str]; }
    function checkerTexture(size=512, squares=16, c1='#0e141b', c2='#101a24'){
      const cv = document.createElement('canvas'); cv.width = cv.height = size; const ctx = cv.getContext('2d');
      const s = size / squares;
      for (let y=0; y<squares; y++) for (let x=0; x<squares; x++) { ctx.fillStyle = (x+y)%2 ? c1 : c2; ctx.fillRect(x*s, y*s, s, s);} 
      const tex = new THREE.CanvasTexture(cv); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.anisotropy = 8; return tex;
    }

    let floorMesh, floorTex; let arena; const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x15202b, metalness:.2, roughness:.8 });
    const wallHeight = 1.25; const wallThickness = 0.4;
    function buildFloor(){
      if (floorMesh) { scene.remove(floorMesh); floorMesh.geometry.dispose(); floorMesh.material.map?.dispose(); floorMesh.material.dispose(); floorTex?.dispose(); }
      const size = CONFIG.GRID_SIZE * CONFIG.CELL; const geo = new THREE.PlaneGeometry(size+4, size+4);
      const [c1,c2] = randomBoard();
      floorTex = checkerTexture(512, 16, c1, c2);
      const mat = new THREE.MeshStandardMaterial({ map: floorTex, metalness:.2, roughness:.9 });
      floorMesh = new THREE.Mesh(geo, mat); floorMesh.rotation.x = -Math.PI/2; floorMesh.position.y = -0.5; floorMesh.receiveShadow = true; scene.add(floorMesh);
    }
    function buildArena(){
      if (arena) { scene.remove(arena); arena.children.forEach(m => { m.geometry.dispose(); m.material.dispose(); }); }
      arena = new THREE.Group();
      function wall(w,h,d,x,y,z){ const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMaterial); m.position.set(x,y,z); m.castShadow = m.receiveShadow = true; return m; }
      const wSpan = CONFIG.GRID_SIZE*CONFIG.CELL + wallThickness*2; const dSpan = CONFIG.GRID_SIZE*CONFIG.CELL + wallThickness*2;
      arena.add(wall(wSpan, wallHeight, wallThickness, 0, wallHeight/2 - 0.5, -CONFIG.GRID_SIZE*CONFIG.CELL/2 - wallThickness/2));
      arena.add(wall(wSpan, wallHeight, wallThickness, 0, wallHeight/2 - 0.5,  CONFIG.GRID_SIZE*CONFIG.CELL/2 + wallThickness/2));
      arena.add(wall(wallThickness, wallHeight, dSpan, -CONFIG.GRID_SIZE*CONFIG.CELL/2 - wallThickness/2, wallHeight/2 - 0.5, 0));
      arena.add(wall(wallThickness, wallHeight, dSpan,  CONFIG.GRID_SIZE*CONFIG.CELL/2 + wallThickness/2, wallHeight/2 - 0.5, 0));
      scene.add(arena);
    }

    // ===== UI =====
    const scoreEl = document.querySelector('#score strong');
    const statusEl = document.getElementById('status');
    const overlay = document.getElementById('overlay');
    const diffSel = document.getElementById('difficulty');
    const wallSel = document.getElementById('walls');
    const camOverhead = document.getElementById('camOverhead');
    const startBtn = document.getElementById('startBtn');
    const muteBtn = document.getElementById('muteBtn');
    const musicBtn = document.getElementById('musicBtn');
    const buffsEl = document.getElementById('buffs');

    // Camera mode
    let overhead = false;
    function updateCamera(){ if (overhead){ camera.position.set(0, CONFIG.GRID_SIZE * 2, 0); } else { camera.position.set(CONFIG.GRID_SIZE * 0.6, CONFIG.GRID_SIZE * 1.1, CONFIG.GRID_SIZE * 1.1); } camera.lookAt(0,0,0); }

    // ===== Audio =====
    const audio = new (window.AudioContext || window.webkitAudioContext)();
    let muted = false;
    // Ensure browsers actually start the AudioContext on user gesture
    async function unlockAudio(){
      try { if (audio.state !== 'running') { await audio.resume(); } } catch(_){}
    }
    function beep({freq=440, dur=0.08, type='sine', gain=0.08}){ if(muted) return; const t0=audio.currentTime; const o=audio.createOscillator(); const g=audio.createGain(); o.type=type; o.frequency.value=freq; g.gain.setValueAtTime(gain,t0); g.gain.exponentialRampToValueAtTime(0.0001,t0+dur); o.connect(g).connect(audio.destination); o.start(t0); o.stop(t0+dur); }
    const SFX = { eat:()=>{beep({freq:660,dur:.07,type:'triangle'});beep({freq:990,dur:.06,type:'triangle'});}, bonk:()=>{beep({freq:180,dur:.12,type:'square',gain:0.12});}, over:()=>{beep({freq:320,dur:.18,type:'sawtooth',gain:0.12});setTimeout(()=>beep({freq:200,dur:.22,type:'sawtooth',gain:0.1}),90);}, power:()=>{beep({freq:520,dur:.12,type:'square'});setTimeout(()=>beep({freq:1040,dur:.08,type:'square'}),80);}, tick:()=>{beep({freq:420,dur:.03,type:'triangle',gain:0.05});} };
    muteBtn.addEventListener('click', () => { muted = !muted; muteBtn.textContent = muted ? 'üîá Sound FX' : 'üîä Sound FX'; muteBtn.setAttribute('aria-pressed', String(!muted)); });

    // ===== Retro 16‚Äëbit style music (synthesized; off by default) =====
    let musicOn = false; let musicTimer = null; const musicGain = audio.createGain(); musicGain.gain.value = 0.2; // gentle background
    function startMusic(){
      stopMusic();
      let i = 0; // tiny looping melody
      const melody = [392,440,523.25,440,392,349.23,392,293.66,392,440,523.25,659.25,587.33,523.25,440,392]; // G A C D ‚Ä¶ simple retro
      musicTimer = setInterval(() => {
        const t = audio.currentTime;
        // Lead square
        const o = audio.createOscillator(); o.type = 'square'; o.frequency.value = melody[i % melody.length];
        const g = audio.createGain(); g.gain.setValueAtTime(0.0001, t); g.gain.exponentialRampToValueAtTime(0.14, t+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
        o.connect(g).connect(musicGain).connect(audio.destination); o.start(t); o.stop(t+0.2);
        // Simple noise hat on the beat
        if ((i % 4) === 0){ const n = audio.createBufferSource(); const buf = audio.createBuffer(1, 2200, audio.sampleRate); const ch = buf.getChannelData(0); for(let k=0;k<ch.length;k++){ ch[k] = Math.random()*2-1; } n.buffer = buf; const ng = audio.createGain(); ng.gain.setValueAtTime(0.04,t); ng.gain.exponentialRampToValueAtTime(0.0001, t+0.04); n.connect(ng).connect(musicGain).connect(audio.destination); n.start(t); }
        i++;
      }, 180);
    }
    function stopMusic(){ if (musicTimer){ clearInterval(musicTimer); musicTimer = null; } }
    musicBtn.addEventListener('click', async () => { await unlockAudio(); musicOn = !musicOn; musicBtn.textContent = musicOn ? 'üéµ Music: On' : 'üéµ Music: Off'; musicBtn.setAttribute('aria-pressed', String(musicOn)); if (musicOn && running) { audio.resume(); startMusic(); } else { stopMusic(); } });

    // ===== Toon materials (colors randomized each game start) =====
    function toonGradient(steps=4){ const c=document.createElement('canvas'); c.width=steps; c.height=1; const ctx=c.getContext('2d'); const g=ctx.createLinearGradient(0,0,steps,0); g.addColorStop(0, '#0a2'); g.addColorStop(.5, '#2ecf53'); g.addColorStop(.8, '#6ef587'); g.addColorStop(1, '#b8ffcc'); ctx.fillStyle=g; ctx.fillRect(0,0,steps,1); const t=new THREE.CanvasTexture(c); t.minFilter=THREE.NearestFilter; t.magFilter=THREE.NearestFilter; t.generateMipmaps=false; return t; }
    const gradientMap = toonGradient(4);
    const bodyMat = new THREE.MeshToonMaterial({ color: 0x2ecf53, gradientMap });
    const headMat = new THREE.MeshToonMaterial({ color: 0x33e06a, gradientMap });
    const bellyMat = new THREE.MeshToonMaterial({ color: 0xf2f2a6, gradientMap });
    function randomizeSnakeColors(){ const h = Math.floor(Math.random()*360); bodyMat.color.setStyle(`hsl(${h} 70% 45%)`); headMat.color.setStyle(`hsl(${(h+10)%360} 70% 55%)`); bellyMat.color.setStyle(`hsl(${h} 50% 80%)`); }
    const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness:.2, metalness:.0 });
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness:.8 });
    const tongueMat = new THREE.MeshStandardMaterial({ color: 0xff3355, roughness:.5, metalness:.1 });

    // ===== Game State =====
    let GRID_SIZE, CELL, TICK_MS, START_LEN, WALL_MODE;
    let snake = []; // {x,z, group}
    let dirVec = { x: 1, z: 0 }; let nextTurn = null; let food = null; let power = null;
    let running = false; let gameOver = false; let lastTick = 0; let score = 0;

    // Jaw/turn animation state
    let turnPulseUntil = 0;
    const CHOMP = {active:false, phase:0, start:0}; // 0:idle, 1:open1,2:close1,3:open2,4:close2

    // Geometries
    const bodyGeo = new THREE.CapsuleGeometry(0.45, 0.1, 6, 12);
    const headGeo = new THREE.CapsuleGeometry(0.52, 0.2, 8, 16);
    const foodGeo = new THREE.SphereGeometry(0.45, 24, 20);

    // Power-ups
    const pMat = { slow:new THREE.MeshStandardMaterial({ color:0x41d1ff, emissive:0x002255, emissiveIntensity:0.9, metalness:.2, roughness:.4 }), ghost:new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0x222222, emissiveIntensity:0.8, transparent:true, opacity:0.7 }), x2:new THREE.MeshStandardMaterial({ color:0xffe066, emissive:0x332200, emissiveIntensity:0.9 }) };
    const pDesc = { slow: 'Slow-mo', ghost: 'Ghost', x2: '√ó2 Points' };
    const active = { slow: 0, ghost: 0, x2: 0 };
    function hasBuff(name){ return performance.now() < active[name]; }

    // Grid helpers
    const mid = () => Math.floor(GRID_SIZE/2);
    function gridToWorld(x, z) { const wx = (x - mid()) * CELL + CELL/2; const wz = (z - mid()) * CELL + CELL/2; return { x: wx, z: wz }; }
    function posKey(x,z){ return `${x},${z}` }

    // Food palette
    function randomFoodColor(){ const colors = [0xff5577, 0x66ff99, 0x41d1ff, 0xffe066, 0xff66cc, 0x99ff66, 0x66ffff]; return colors[Math.floor(Math.random()*colors.length)]; }

    // Segment creation (cartoon head with eyes/tongue/jaw)
    function createSegmentGroup(isHead){
      const group = new THREE.Group();
      const cap = new THREE.Mesh(isHead ? headGeo : bodyGeo, isHead ? headMat : bodyMat);
      cap.castShadow = cap.receiveShadow = true;
      const belly = new THREE.Mesh(isHead ? headGeo : bodyGeo, bellyMat); belly.scale.set(0.7,0.7,0.7); belly.position.y=-0.2;
      group.add(cap, belly);
      group.capsule = cap;
      if (isHead){
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.11,16,12), eyeWhiteMat);
        const eyeR = eyeL.clone(); eyeL.position.set(0.35,0.18, 0.18); eyeR.position.set(0.35,0.18,-0.18);
        const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.05,12,10), pupilMat); pupilL.position.set(0.09,0,0);
        const pupilR = pupilL.clone(); eyeL.add(pupilL); eyeR.add(pupilR);
        group.add(eyeL, eyeR); group.eyeL=eyeL; group.eyeR=eyeR;
        const tongue = new THREE.Mesh(new THREE.BoxGeometry(0.28,0.04,0.04), tongueMat); tongue.position.set(0.55,-0.05,0); group.add(tongue); group.tongue=tongue;
        const jawPivot = new THREE.Group(); jawPivot.position.set(0.45,-0.02,0); const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.32,0.06,0.24), bellyMat); jaw.position.set(0.16,-0.02,0); jawPivot.add(jaw); group.add(jawPivot); group.jawPivot=jawPivot;
      }
      return group;
    }
    function stripHeadExtras(group){ if (!group) return; if (group.eyeL){ group.remove(group.eyeL); group.eyeL.geometry.dispose(); } if (group.eyeR){ group.remove(group.eyeR); group.eyeR.geometry.dispose(); } if (group.tongue){ group.remove(group.tongue); group.tongue.geometry.dispose(); } if (group.jawPivot){ group.remove(group.jawPivot); } group.eyeL=group.eyeR=group.tongue=group.jawPivot=null; group.capsule.material = bodyMat; }
    function promoteToHead(group){ if (!group) return group; if (!group.eyeL){ const extras = createSegmentGroup(true); extras.position.copy(group.position); extras.rotation.copy(group.rotation); extras.scale.copy(group.scale); scene.add(extras); scene.remove(group); return extras; } group.capsule.material = headMat; return group; }
    function setHeadFacing(group, dir){ let a=0; if (dir.x===1) a=0; if (dir.x===0&&dir.z===1) a=Math.PI/2; if (dir.x===-1) a=Math.PI; if (dir.x===0&&dir.z===-1) a=-Math.PI/2; group.rotation.y=a; }

    function addSegment(x,z, isHead=false){ const group = createSegmentGroup(isHead); const {x:wx,z:wz}=gridToWorld(x,z); group.position.set(wx,0,wz); scene.add(group); snake.unshift({ x, z, group }); if (snake.length>1) stripHeadExtras(snake[1].group); if (!isHead){ const rep=promoteToHead(group); snake[0].group=rep; } setHeadFacing(snake[0].group, dirVec); }
    function removeTail(){ const seg = snake.pop(); scene.remove(seg.group); }

    // Food & power-ups
    function spawnFood(){ if (food) { scene.remove(food.mesh); food = null; } const occ = new Set(snake.map(s=>posKey(s.x,s.z))); if (power) occ.add(posKey(power.x,power.z)); let x,z; do { x = Math.floor(Math.random()*GRID_SIZE); z = Math.floor(Math.random()*GRID_SIZE); } while(occ.has(posKey(x,z))); const foodMat = new THREE.MeshStandardMaterial({ color: randomFoodColor(), metalness:0.1, roughness:0.2, emissive:0x22000a, emissiveIntensity:0.7 }); const orb = new THREE.Mesh(foodGeo, foodMat); const {x:wx,z:wz}=gridToWorld(x,z); orb.position.set(wx,0,wz); orb.castShadow=orb.receiveShadow=true; scene.add(orb); food = { x, z, mesh: orb }; }
    function maybeSpawnPower(){ if (power) return; if (Math.random() > CONFIG.POWERUP_RATE) return; const types=['slow','ghost','x2']; const type=types[Math.floor(Math.random()*types.length)]; const occ=new Set(snake.map(s=>posKey(s.x,s.z))); if (food) occ.add(posKey(food.x,food.z)); let x,z; do { x=Math.floor(Math.random()*GRID_SIZE); z=Math.floor(Math.random()*GRID_SIZE); } while(occ.has(posKey(x,z))); const gem=new THREE.Mesh(new THREE.IcosahedronGeometry(0.5,1), pMat[type]); const {x:wx,z:wz}=gridToWorld(x,z); gem.position.set(wx,0,wz); gem.castShadow=gem.receiveShadow=true; scene.add(gem); power={ type, x, z, mesh: gem, until:0 }; }
    function applyPower(type){ SFX.power(); const until = performance.now() + CONFIG.POWERUP_DURATION_MS; if (type==='slow') active.slow=until; if (type==='ghost') active.ghost=until; if (type==='x2') active.x2=until; updateBuffs(); }
    function clearPower(){ if (!power) return; scene.remove(power.mesh); power=null; }

    function updateBuffs(){ const parts=[]; for (const k of Object.keys(active)){ const left=Math.max(0, Math.ceil((active[k]-performance.now())/1000)); if (left>0) parts.push(`<span class="tag">${{slow:'Slow-mo',ghost:'Ghost',x2:'√ó2 Points'}[k]} ${left}s</span>`);} if (parts.length){ buffsEl.style.display='block'; buffsEl.innerHTML=parts.join(' ');} else { buffsEl.style.display='none'; buffsEl.textContent=''; } }
    function setStatus(text){ statusEl.textContent = text }

    function resetGame(){
      const d = DIFF[diffSel.value]; CONFIG.GRID_SIZE = d.GRID_SIZE; CONFIG.TICK_MS = d.TICK_MS; CONFIG.WALL_MODE = wallSel.value; overhead = camOverhead.checked;
      GRID_SIZE = CONFIG.GRID_SIZE; CELL = CONFIG.CELL; TICK_MS = CONFIG.TICK_MS; START_LEN = CONFIG.START_LEN; WALL_MODE = CONFIG.WALL_MODE;
      snake.forEach(s => { scene.remove(s.group); }); snake = [];
      if (food) { scene.remove(food.mesh); food = null; }
      clearPower(); Object.keys(active).forEach(k => active[k] = 0); updateBuffs();
      score = 0; scoreEl.textContent = score; dirVec = { x: 1, z: 0 }; nextTurn = null; gameOver = false; lastTick = 0; running = false; CHOMP.active=false; CHOMP.phase=0;
      buildFloor(); buildArena(); updateCamera();
      randomizeSnakeColors();
      const startX = Math.floor(GRID_SIZE/2) - Math.floor(START_LEN/2);
      for (let i = 0; i < START_LEN; i++) addSegment(startX + i, Math.floor(GRID_SIZE/2), i === START_LEN-1);
      spawnFood(); setStatus('Ready'); overlay.style.display = ''; overlay.querySelector('h2').textContent = '3D Snake';
    }

    function start(){ if (gameOver) resetGame(); running = true; setStatus('Playing'); overlay.style.display='none'; audio.resume(); if (musicOn) startMusic(); }
    function startFromMenu(){ resetGame(); start(); }
    function pause(){ running = false; setStatus('Paused'); overlay.style.display=''; overlay.querySelector('h2').textContent = 'Paused'; overlay.querySelector('p').innerHTML = 'Press <kbd>Enter</kbd> to resume.'; stopMusic(); }
    function turn(dx, dz){ if (dx === -dirVec.x && dz === -dirVec.z) return; nextTurn = { x: dx, z: dz }; }

    // Tick
    function doTick(){
      const head = snake[0]; let nx = head.x + dirVec.x; let nz = head.z + dirVec.z;
      if (WALL_MODE === 'wrap'){ nx = (nx + GRID_SIZE) % GRID_SIZE; nz = (nz + GRID_SIZE) % GRID_SIZE; }
      else { if (nx < 0 || nz < 0 || nx >= GRID_SIZE || nz >= GRID_SIZE) { SFX.bonk(); return endGame('You hit the wall'); } }
      if (!hasBuff('ghost')){ for (let i = 0; i < snake.length; i++) if (snake[i].x === nx && snake[i].z === nz) { SFX.bonk(); return endGame('You bit yourself'); } }
      addSegment(nx, nz, true);
      if (power && nx === power.x && nz === power.z) { applyPower(power.type); clearPower(); }
      if (food && nx === food.x && nz === food.z) {
        const add = (10 * (hasBuff('x2') ? 2 : 1)); score += add; scoreEl.textContent = score; SFX.eat();
        // Trigger double chomp animation
        CHOMP.active = true; CHOMP.phase = 1; CHOMP.start = performance.now();
        spawnFood(); maybeSpawnPower();
      } else {
        removeTail();
      }
      setHeadFacing(snake[0].group, dirVec);
    }

    // Options live preview
    diffSel.addEventListener('change', () => { if (!running) { const d = DIFF[diffSel.value]; CONFIG.GRID_SIZE=d.GRID_SIZE; CONFIG.TICK_MS=d.TICK_MS; buildFloor(); buildArena(); updateCamera(); } });
    wallSel.addEventListener('change', () => { if (!running) { CONFIG.WALL_MODE = wallSel.value; }});
    camOverhead.addEventListener('change', () => { if (!running) { overhead = camOverhead.checked; updateCamera(); }});

    startBtn.addEventListener('click', async () => { await unlockAudio(); startFromMenu(); });

    // Keyboard
    window.addEventListener('keydown', async (e) => { if (e.key === 'Enter'){ await unlockAudio(); return startFromMenu(); } if (e.key === 'p' || e.key === 'P') { running ? pause() : start(); } if (e.key === 'r' || e.key === 'R') { resetGame(); start(); } if (!running) return; if (['ArrowUp','w','W'].includes(e.key)) turn(0,-1); if (['ArrowDown','s','S'].includes(e.key)) turn(0, 1); if (['ArrowLeft','a','A'].includes(e.key)) turn(-1,0); if (['ArrowRight','d','D'].includes(e.key)) turn(1, 0); });

    // Mobile buttons
    document.querySelectorAll('.btnbar button').forEach(btn => { btn.addEventListener('click', async () => { await unlockAudio(); start(); const dir = btn.getAttribute('data-dir'); if (dir==='up') turn(0,-1); if (dir==='down') turn(0,1); if (dir==='left') turn(-1,0); if (dir==='right') turn(1, 0); }); });

    // Virtual Joystick (cardinal directions)
    (function setupVJoy(){
      const vjoy = document.getElementById('vjoy'); if (!vjoy) return;
      const knob = vjoy.querySelector('.knob');
      const R = 60; // px radius to clamp knob
      const DEAD = 18; // px dead zone
      let lastDir = {x:1,z:0};
      let down = false; let rect, cx, cy;
      function setKnob(dx,dy){ const mag=Math.hypot(dx,dy); const cl = Math.min(mag, R); const a = Math.atan2(dy, dx); const x = Math.cos(a)*cl; const y = Math.sin(a)*cl; knob.style.transform = `translate(${x}px, ${y}px)`; }
      function dirFrom(dx,dy){ const ax=Math.abs(dx), ay=Math.abs(dy); if (Math.max(ax,ay) < DEAD) return null; return (ax>ay) ? {x:dx>0?1:-1,z:0} : {x:0,z:dy>0?1:-1}; }
      function sameDir(a,b){ return a && b && a.x===b.x && a.z===b.z; }
      function isReverse(a,b){ return a && b && a.x===-b.x && a.z===-b.z; }
      function onDown(ev){ down=true; rect=vjoy.getBoundingClientRect(); cx=rect.left+rect.width/2; cy=rect.top+rect.height/2; setKnob(0,0); ev.preventDefault(); }
      async function onMove(ev){ if(!down) return; const p = ev.touches? ev.touches[0] : ev; const dx = p.clientX - cx; const dy = p.clientY - cy; setKnob(dx,dy); const d = dirFrom(dx,dy); if (d && !sameDir(d,lastDir) && !isReverse(d, lastDir)){ await unlockAudio(); if (!running) start(); turn(d.x, d.z); lastDir = d; } ev.preventDefault(); }
      function onUp(){ down=false; knob.style.transform = 'translate(0px,0px)'; }
      vjoy.addEventListener('pointerdown', (e)=>{ vjoy.setPointerCapture(e.pointerId); onDown(e); });
      vjoy.addEventListener('pointermove', onMove, {passive:false});
      vjoy.addEventListener('pointerup', onUp);
      vjoy.addEventListener('pointercancel', onUp);
      // Touch fallback (Safari older)
      vjoy.addEventListener('touchstart', onDown, {passive:false});
      vjoy.addEventListener('touchmove', onMove, {passive:false});
      vjoy.addEventListener('touchend', onUp);
    })();

    // Resize
    function onResize(){ const w = stage.clientWidth || window.innerWidth; const h = stage.clientHeight || (window.innerHeight - 84); renderer.setSize(w, h, false); camera.aspect = w / h; camera.updateProjectionMatrix(); updateCamera(); }
    window.addEventListener('resize', onResize);

    // ===== Loop =====
    function step(){
      const now = performance.now();
      requestAnimationFrame(step);
      if (!running) { renderer.render(scene, camera); return; }

      updateBuffs();
      const speed = hasBuff('slow') ? TICK_MS * 1.8 : TICK_MS;

      let changedDir = false;
      if (nextTurn) { dirVec = nextTurn; nextTurn = null; changedDir = true; }
      if (now - lastTick >= speed) { lastTick = now; SFX.tick(); doTick(); }
      if (changedDir) turnPulseUntil = now + 200;

      // Per-segment toon motion + squash/stretch
      for (let i=0;i<snake.length;i++){
        const g = snake[i].group;
        const t = now*0.003 + i*0.25;
        const wag = (i > snake.length-6 ? Math.sin(t)*0.12 : Math.sin(t)*0.06);
        g.rotation.y += wag*0.01;
        g.position.y = Math.sin(t*1.6)*0.03;
        const tickPhase = Math.min(1, Math.max(0, (now - lastTick) / speed));
        let k = 0.06 * Math.sin(tickPhase * Math.PI);
        if (now < turnPulseUntil) k += 0.10;
        const fall = Math.max(0, 1 - i*0.08);
        const sX = 1 + k*fall;
        const sYZ = 1 - (k*0.5)*fall;
        g.scale.set(sX, sYZ, sYZ);
      }

      // Head-specific: blink, tongue flick, and DOUBLE CHOMP jaw
      const hg = snake[0]?.group;
      if (hg){
        const blink = (Math.sin(now*0.006)+1)/2; const closed = blink > 0.92; if (hg.eyeL&&hg.eyeR){ const sY = closed ? 0.15 : 1.0; hg.eyeL.scale.y=sY; hg.eyeR.scale.y=sY; }
        const biting = CHOMP.active;
        if (hg.tongue){ const flick = biting ? 0.25 : ((Math.sin(now*0.02) > 0.8) ? (0.6 + 0.4*Math.sin(now*0.1)) : 0.2); hg.tongue.scale.x = flick; }
        if (hg.jawPivot){
          const dur = 120; // per open/close
          if (CHOMP.active){
            const elapsed = now - CHOMP.start;
            const stepIndex = Math.floor(elapsed / dur) + 1; // 1..N
            CHOMP.phase = stepIndex;
            if (stepIndex > 4){ CHOMP.active=false; CHOMP.phase=0; hg.jawPivot.rotation.z=0; }
            else {
              const localT = (elapsed % dur) / dur; // 0..1
              const curve = Math.sin(localT * Math.PI); // ease
              const openAmt = 0.7;
              let ang = 0;
              if (stepIndex===1) ang = -openAmt*curve;       // open1
              if (stepIndex===2) ang = -openAmt*(1-curve);   // close1
              if (stepIndex===3) ang = -openAmt*curve;       // open2
              if (stepIndex===4) ang = -openAmt*(1-curve);   // close2
              hg.jawPivot.rotation.z = ang;
            }
          }
        }
      }

      renderer.render(scene, camera);
    }

    function endGame(reason){ running = false; gameOver = true; setStatus('Game Over'); stopMusic(); SFX.over(); overlay.style.display = ''; overlay.querySelector('h2').textContent = 'Game Over'; overlay.querySelector('p').innerHTML = `${reason}. Press <kbd>R</kbd> to restart.`; if (score > highScore){ highScore = score; localStorage.setItem(HI_KEY, String(highScore)); hiEl.textContent = highScore; } }

    // Boot
    buildFloor(); buildArena(); updateCamera(); onResize(); resetGame(); requestAnimationFrame(step);

    // Basic runtime checks (console only)
    console.assert(typeof CONFIG === 'object' && CONFIG.GRID_SIZE>0, 'CONFIG ok');
    console.assert(scene instanceof THREE.Scene && renderer instanceof THREE.WebGLRenderer, 'Scene/Renderer ok');
  })();
  </script>


</body></html>